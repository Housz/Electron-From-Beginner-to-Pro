# Getting Started
先来修改`package.json`的节点以适应我们的应用   
1. 将`name`改为"brower-window-sample"。
2. 将`version`改为"0.0.1"。如果你不熟悉版本含义，可将版本号分为三部分：MAJOR.MINOR.PATCH。我们将应用版本从0.0.1开始。
3. 将`description`改为类似"A sample Electron application to demonstrate BrowserWindow creation"的表述语句。
4. 删除`repository`节点。如果你要将代码放在自己的版本库，也可将改为相应目录。
5. 将`keywords`改为"Electron," "BrowserWindow," "sample"。
6. 将`author`改为你自己的名字
7. 如果想修改许可类型，可以将`licence`改为相应的类型。默认为CC0-1.0。有各种许可类型可供使用，选择最适合你的一种来修改。

## 禁用Chrome开发者工具
本小节我们将反复启动和关闭应用来观察不同设置对窗口的影响。为此要关闭Chrome开发者工具（Chrome DevTools）以防影响我们观察效果。在`main.js`中找到如下代码片段，将`mainWindow.webContents.openDevTools()`注释掉即可：
```
// Open the DevTools.   
// mainWindow.webContents.openDevTools()
```
现在DevTools已经被禁用了,可以观察默认代码在禁用DevTools时的运行效果。在项目根目录下打开控制台，输入：
```
npm start
```

[4.1](https://github.com/Housz/Electron-From-Beginner-to-Pro/blob/master/imgs/4.1.jpg)  
*Figure 4-1. The starter Electron window without the Chrome DevTools*  

记住这个我们将要多次使用的命令。  

如图所示只显示了单个窗口,除此之外就空无一物了。

## createWindw方法

再来研究一下`main.js`中创建窗口的`createWindw`方法：
```
function createWindow () {
  // Create the browser window.
  mainWindow = new BrowserWindow({width: 800, height: 600})

  // and load the index.html of the app.
  mainWindow.loadURL(url.format({
    pathname: path.join(__dirname, 'index.html'),
    protocol: 'file:',
    slashes: true
  }))

  // Open the DevTools.
  // mainWindow.webContents.openDevTools()

  // Emitted when the window is closed.
  mainWindow.on('closed', function () {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    mainWindow = null
  })
}
```
当`createWindow`被调用时，通过调用`BrowserWindow`的构造函数创建一个`mainWindow`变量。构造函数的参数规定了窗口的宽高，以对象形式传入。

接下来调用`mainWindow`的`loadURL`方法，参数通过Node的url模块创建。url模块是一个用来创建和格式URL的Node模块：
```
  // and load the index.html of the app.
  mainWindow.loadURL(url.format({
    pathname: path.join(__dirname, 'index.html'),
    protocol: 'file:',
    slashes: true
  }))
```
url模块中的`format`方法用来创建到文件的链接，渲染进程就能够渲染这个文件了。注意方法中参数的意义。以下是Node中创建URL的典型方法：
* `pathname`：使用Node的`path`模块生成一个字符串来来连接两个对象：Node全局变量`__dirname`和待渲染文件（如index.html）。
* `protocol`：指定加载协议类型。Electron项目通常使用`'file:'`,注意冒号的使用。
* `slashes`：当为true时为`protocol`加入'//'，使其成为`'file:///'`，此时使`protocol`正确使用三斜线。

当我们将文件加载到窗口时，需要添加一个监听器（listener）来捕捉`closed`事件，并将`mainWindow `变量置空：
```
  // Emitted when the window is closed.
  mainWindow.on('closed', function () {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    mainWindow = null
  })
```


## 使用ready-to-show事件
首先要做的是：在窗口加载之前，建立一个等待`BrowserWindow`的`ready-to-show`事件的方法。这是一种Electron官方文档所推荐的做法，但常常被忽视。  

如果像先前方式组织代码——直接创建`BrowserWindow`，渲染进程会立即将其显示出来。但是待显示的内容可能未被完全渲染。为避免发生这种情况，我们要监听`ready-to-show`事件并调用`BrowserWindow`的`show()`方法来显示窗口。

按如下方式修改`createWindow`方法：
```
function createWindow () {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    show: false,
    backgroundColor: '#FFF',
    width: 800, 
    height: 600
  })

  // and load the index.html of the app.
  mainWindow.loadURL(url.format({
    pathname: path.join(__dirname, 'index.html'),
    protocol: 'file:',
    slashes: true
  }))

  // Open the DevTools.
  // mainWindow.webContents.openDevTools()

  // Wait for 'ready-to-show' to display our window
  mainWindow.once('ready-to-show', ()=> {
    mainWindow.show();
  })

  // Emitted when the window is closed.
  mainWindow.on('closed', function () {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    mainWindow = null
  })
}
```
如上所示，我们为`BrowserWindow`参数对象添加`show`属性并置为false，这样就能防止创建显示窗口。然后添加`backgroundColor`属性。最好的做法是尝试匹配应用的背景颜色，这样能保证如果窗口在内容之前呈现，在显示窗口默认的白色（#FFF）和显示应用背景之间不会出现闪烁。在`show`属性为true时这是一个避免闪烁有效的做法，通常应该遵守。此外，`backgroundColor`属性只能接受十六进制表示的颜色参数。

最后添加了一个一个监听器来监听`ready-to-show`事件。在当前示例中，我们没有像真正的应用中加载太多的代码和资源，所以这个事件发生的很快。

此外，在监听器中我们使用了ES6的`箭头函数`，如果你不熟悉这种语法，完全可以用一个简单的回调函数来代替。例如一个乘法函数在ES5规范中可以这么写：
```
var multiply = function (x, y) {
  return x * y;
}
```
而利用ES6的箭头函数可以简写为：
```
var multiply = (x, y) => { return x * y }
```

至此已经搭建了实用的开发环境，接下来我们就可以去将`BrowserWindow`一探究竟了。

# Synchronous IPC Messaging
我们先为按钮和响应字段定义简单样式，样式效果如图6.2所示。  
在`index.html`中将`<head>`标签内容替换为：
```
<style>
	p {
		font-family: sans-serif;
		border: 1px solid #ccc;
		border-radius: 4px;
		padding: .5rem;
		background-color: #ddd;
		box-shadow: inset 0 0 2px #aaa;
	}
	
	button {
		color: rebeccapurple;
		font-family: sans-serif;
		font-weight: bold;
		padding: .5rem;
		background-color: #ccc;
		box-shadow: 2px 2px 2px #ccc;
	}
</style>
```
然后将`<body>`标签内容替换为：
```
<button id="sendSyncMsgBtn">Ping Main Process</button>
<p id="syncReply">Awaiting response</p>
```
       
![6.2](https://github.com/Housz/Electron-From-Beginner-to-Pro/blob/master/imgs/6.2.jpg)    
*Figure 6-2. Our Electron application with our button*     

然后在`renderer.js`中来添加按钮被点击时触发的的代码和接受响应的代码。   
首先需要导入相应的`IPC`模块。由于代码将被在渲染进程中执行，所以我们要用到`IPCRenderer`模块：
```
const ipc = require('electron').ipcRenderer
```
接着需要引用按钮：
```
const syncMsgBtn = document.getElementById('sendSyncMsgBtn')
```
为按钮引用添加监听器：
```
syncMsgBtn.addEventListener('click', function () {

})
```
正如牛顿第三定律中力与反作用力的依存关系，IPC模块的每个动作都要有一个相对的事件与之对应。对于每个IPC发送，必须有相对应的接受方法。   
基本框架如下：
```
ipcRenderer.sendSync(channel, [, arg1][, arg2], [,...])
```
其中`channel`值是一个被当作消息标识符的字符串，而配合使用的方法会监听这个标识符。你也可以使用参数发送附加消息，消息可以是任何JavaScript原生类型（字符串、数值、数组和对象类型）。我们在回调函数中发送贝尔的名言：
```
syncMsgBtn.addEventListener('click', function () {
    const reply = ipc.sendSync('synchronous', 'Mr. Watson, come here.')
})
```
每次使用IPC事件时，一旦我们编写了发送函数，就一定要在另一个进程中写相应的桩函数（stub function）。所以我们要切换到主进程对应的`main.js`中。

主进程中同样要导入相应IPC模块，也就是`ipcMain`：
```
const ipc = electron.ipcMain
```
接着就要写接受函数了。这个函数直截了当定义了应当监听的`channel`，然后用一个函数去响应。
```
ipc.on('synchronous-message', function (event, arg) {
  
})
```
> ***Note***







